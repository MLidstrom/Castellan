using System.Net;
using System.Text;
using System.Text.Json;
using Castellan.Worker.Models.ThreatIntelligence;
using Castellan.Worker.Services.Interfaces;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Castellan.Worker.Services;

/// <summary>
/// MalwareBazaar (Abuse.ch) threat intelligence service implementation
/// </summary>
public class MalwareBazaarService : IMalwareBazaarService, IDisposable
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<MalwareBazaarService> _logger;
    private readonly IThreatIntelligenceCacheService _cacheService;
    private readonly MalwareBazaarOptions _options;
    private readonly SemaphoreSlim _rateLimitSemaphore;
    private readonly object _rateLimitLock = new();
    
    // Rate limiting tracking
    private DateTime _lastRequestTime = DateTime.MinValue;
    private int _requestsInCurrentMinute = 0;
    private DateTime _currentMinuteStart = DateTime.UtcNow;

    private const string SOURCE_NAME = "MalwareBazaar";

    public MalwareBazaarService(
        HttpClient httpClient,
        IOptions<ThreatIntelligenceOptions> options,
        IThreatIntelligenceCacheService cacheService,
        ILogger<MalwareBazaarService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        _cacheService = cacheService;
        _options = options.Value.MalwareBazaar;
        
        // Configure HTTP client
        _httpClient.BaseAddress = new Uri(_options.BaseUrl);
        _httpClient.Timeout = TimeSpan.FromSeconds(_options.TimeoutSeconds);
        _httpClient.DefaultRequestHeaders.Add("User-Agent", "Castellan-Security-Scanner/1.0");

        // Initialize rate limiting
        _rateLimitSemaphore = new SemaphoreSlim(_options.RateLimit.RequestsPerMinute, _options.RateLimit.RequestsPerMinute);
        
        _logger.LogInformation("MalwareBazaar service initialized with base URL: {BaseUrl}", _options.BaseUrl);
    }

    public async Task<MalwareBazaarResult?> GetHashInfoAsync(string fileHash, CancellationToken cancellationToken = default)
    {
        if (!_options.Enabled)
        {
            _logger.LogDebug("MalwareBazaar service is disabled");
            return null;
        }

        if (string.IsNullOrWhiteSpace(fileHash))
        {
            _logger.LogWarning("File hash is null or empty");
            return null;
        }

        // Normalize hash to lowercase (MalwareBazaar expects lowercase)
        var normalizedHash = fileHash.Trim().ToLowerInvariant();
        
        // Check cache first
        var cachedResult = _cacheService.Get<MalwareBazaarResult>(normalizedHash, SOURCE_NAME);
        if (cachedResult != null)
        {
            _logger.LogDebug("Retrieved MalwareBazaar result from cache for hash: {Hash}", normalizedHash);
            return cachedResult;
        }

        // Apply rate limiting
        if (!await WaitForRateLimitAsync(cancellationToken))
        {
            _logger.LogWarning("Rate limit exceeded for MalwareBazaar API");
            return null;
        }

        try
        {
            _logger.LogDebug("Querying MalwareBazaar for hash: {Hash}", normalizedHash);

            // MalwareBazaar uses POST requests with form data
            var postData = new FormUrlEncodedContent(new[]
            {
                new KeyValuePair<string, string>("query", "get_info"),
                new KeyValuePair<string, string>("hash", normalizedHash)
            });

            var response = await RetryHttpRequest(
                () => _httpClient.PostAsync("", postData, cancellationToken),
                cancellationToken);

            if (response == null)
            {
                _logger.LogError("Failed to get response from MalwareBazaar after retries");
                return null;
            }

            var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
            
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError("MalwareBazaar API returned error status: {StatusCode}, Content: {Content}", 
                    response.StatusCode, jsonContent);
                return null;
            }

            var mbResponse = JsonSerializer.Deserialize<MalwareBazaarResponse>(jsonContent);
            if (mbResponse == null)
            {
                _logger.LogError("Failed to deserialize MalwareBazaar response");
                return null;
            }

            var result = MapToResult(mbResponse, normalizedHash);
            
            // Cache the result
            if (result != null)
            {
                _cacheService.Set(normalizedHash, result, _options.CacheExpiryHours);
                _logger.LogDebug("Cached MalwareBazaar result for hash: {Hash}", normalizedHash);
            }

            return result;
        }
        catch (TaskCanceledException ex) when (ex.InnerException is TimeoutException)
        {
            _logger.LogError("MalwareBazaar request timed out for hash: {Hash}", normalizedHash);
            return null;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP request failed for MalwareBazaar query: {Hash}", normalizedHash);
            return null;
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "Failed to parse MalwareBazaar response for hash: {Hash}", normalizedHash);
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error querying MalwareBazaar for hash: {Hash}", normalizedHash);
            return null;
        }
    }

    public async Task<List<MalwareBazaarResult>> GetBySignatureAsync(string signature, int limit = 100, CancellationToken cancellationToken = default)
    {
        if (!_options.Enabled || string.IsNullOrWhiteSpace(signature))
            return new List<MalwareBazaarResult>();

        if (!await WaitForRateLimitAsync(cancellationToken))
            return new List<MalwareBazaarResult>();

        try
        {
            var postData = new FormUrlEncodedContent(new[]
            {
                new KeyValuePair<string, string>("query", "get_siginfo"),
                new KeyValuePair<string, string>("signature", signature),
                new KeyValuePair<string, string>("limit", limit.ToString())
            });

            var response = await RetryHttpRequest(
                () => _httpClient.PostAsync("", postData, cancellationToken),
                cancellationToken);

            if (response?.IsSuccessStatusCode == true)
            {
                var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
                var mbResponse = JsonSerializer.Deserialize<MalwareBazaarResponse>(jsonContent);
                return MapToResults(mbResponse);
            }

            return new List<MalwareBazaarResult>();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error querying MalwareBazaar by signature: {Signature}", signature);
            return new List<MalwareBazaarResult>();
        }
    }

    public async Task<List<MalwareBazaarResult>> GetByClamAVAsync(string clamavSignature, int limit = 100, CancellationToken cancellationToken = default)
    {
        if (!_options.Enabled || string.IsNullOrWhiteSpace(clamavSignature))
            return new List<MalwareBazaarResult>();

        if (!await WaitForRateLimitAsync(cancellationToken))
            return new List<MalwareBazaarResult>();

        try
        {
            var postData = new FormUrlEncodedContent(new[]
            {
                new KeyValuePair<string, string>("query", "get_clamavinfo"),
                new KeyValuePair<string, string>("clamav", clamavSignature),
                new KeyValuePair<string, string>("limit", limit.ToString())
            });

            var response = await RetryHttpRequest(
                () => _httpClient.PostAsync("", postData, cancellationToken),
                cancellationToken);

            if (response?.IsSuccessStatusCode == true)
            {
                var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
                var mbResponse = JsonSerializer.Deserialize<MalwareBazaarResponse>(jsonContent);
                return MapToResults(mbResponse);
            }

            return new List<MalwareBazaarResult>();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error querying MalwareBazaar by ClamAV: {ClamAV}", clamavSignature);
            return new List<MalwareBazaarResult>();
        }
    }

    public async Task<List<MalwareBazaarResult>> GetRecentSamplesAsync(int limit = 100, CancellationToken cancellationToken = default)
    {
        if (!_options.Enabled)
            return new List<MalwareBazaarResult>();

        if (!await WaitForRateLimitAsync(cancellationToken))
            return new List<MalwareBazaarResult>();

        try
        {
            var postData = new FormUrlEncodedContent(new[]
            {
                new KeyValuePair<string, string>("query", "get_recent"),
                new KeyValuePair<string, string>("selector", "time"),
                new KeyValuePair<string, string>("limit", limit.ToString())
            });

            var response = await RetryHttpRequest(
                () => _httpClient.PostAsync("", postData, cancellationToken),
                cancellationToken);

            if (response?.IsSuccessStatusCode == true)
            {
                var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
                var mbResponse = JsonSerializer.Deserialize<MalwareBazaarResponse>(jsonContent);
                return MapToResults(mbResponse);
            }

            return new List<MalwareBazaarResult>();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting recent samples from MalwareBazaar");
            return new List<MalwareBazaarResult>();
        }
    }

    public async Task<bool> IsHealthyAsync(CancellationToken cancellationToken = default)
    {
        if (!_options.Enabled)
            return false;

        try
        {
            // Use a known hash that should exist in MalwareBazaar (test with recent samples)
            var recentSamples = await GetRecentSamplesAsync(1, cancellationToken);
            return recentSamples.Any(); // If we get any results, the service is working
        }
        catch
        {
            return false;
        }
    }

    public async Task<RateLimitStatus> GetRateLimitStatusAsync()
    {
        lock (_rateLimitLock)
        {
            UpdateRateLimitCounters();
            
            return new RateLimitStatus
            {
                RequestsRemaining = Math.Max(0, _options.RateLimit.RequestsPerMinute - _requestsInCurrentMinute),
                RequestsPerMinute = _options.RateLimit.RequestsPerMinute,
                RequestsPerDay = _options.RateLimit.RequestsPerDay,
                ResetTime = _currentMinuteStart.AddMinutes(1),
                IsLimitExceeded = _requestsInCurrentMinute >= _options.RateLimit.RequestsPerMinute
            };
        }
    }

    public void ClearCache(string fileHash)
    {
        _cacheService.Remove(fileHash, SOURCE_NAME);
        _logger.LogDebug("Cleared MalwareBazaar cache for hash: {Hash}", fileHash);
    }

    public void ClearAllCache()
    {
        _cacheService.Clear();
        _logger.LogDebug("Cleared all MalwareBazaar cache entries");
    }

    private async Task<bool> WaitForRateLimitAsync(CancellationToken cancellationToken)
    {
        lock (_rateLimitLock)
        {
            UpdateRateLimitCounters();
            
            if (_requestsInCurrentMinute >= _options.RateLimit.RequestsPerMinute)
            {
                var waitTime = _currentMinuteStart.AddMinutes(1) - DateTime.UtcNow;
                if (waitTime.TotalMilliseconds > 0)
                {
                    _logger.LogDebug("Rate limit reached, waiting {Seconds} seconds", waitTime.TotalSeconds);
                    return false;
                }
            }

            // Increment counters
            _requestsInCurrentMinute++;
            _lastRequestTime = DateTime.UtcNow;
        }

        // Wait for semaphore outside the lock
        return await _rateLimitSemaphore.WaitAsync(1000, cancellationToken);
    }

    private void UpdateRateLimitCounters()
    {
        var now = DateTime.UtcNow;
        
        // Reset minute counter if needed
        if (now >= _currentMinuteStart.AddMinutes(1))
        {
            _requestsInCurrentMinute = 0;
            _currentMinuteStart = new DateTime(now.Year, now.Month, now.Day, now.Hour, now.Minute, 0);
        }
    }

    private async Task<HttpResponseMessage?> RetryHttpRequest(
        Func<Task<HttpResponseMessage>> requestFunc, 
        CancellationToken cancellationToken)
    {
        for (int attempt = 0; attempt < _options.RetryAttempts; attempt++)
        {
            try
            {
                var response = await requestFunc();
                
                // Don't retry on client errors (4xx), only on server errors (5xx) or network issues
                if (response.IsSuccessStatusCode || 
                    ((int)response.StatusCode >= 400 && (int)response.StatusCode < 500))
                {
                    return response;
                }

                if (attempt < _options.RetryAttempts - 1)
                {
                    var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt)); // Exponential backoff
                    _logger.LogWarning("Request failed with status {StatusCode}, retrying in {Delay} seconds (attempt {Attempt}/{Total})", 
                        response.StatusCode, delay.TotalSeconds, attempt + 1, _options.RetryAttempts);
                    
                    await Task.Delay(delay, cancellationToken);
                }

                response.Dispose();
            }
            catch (Exception ex) when (attempt < _options.RetryAttempts - 1)
            {
                var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt));
                _logger.LogWarning(ex, "Request failed, retrying in {Delay} seconds (attempt {Attempt}/{Total})", 
                    delay.TotalSeconds, attempt + 1, _options.RetryAttempts);
                
                await Task.Delay(delay, cancellationToken);
            }
        }

        return null;
    }

    private MalwareBazaarResult? MapToResult(MalwareBazaarResponse mbResponse, string hash)
    {
        if (mbResponse?.QueryStatus != "ok" || mbResponse.Data?.Any() != true)
        {
            _logger.LogDebug("Hash not found in MalwareBazaar: {Hash}", hash);
            return null;
        }

        var data = mbResponse.Data.First();
        var riskLevel = CalculateRiskLevel(data);
        var confidenceScore = CalculateConfidenceScore(data);

        return new MalwareBazaarResult
        {
            Source = SOURCE_NAME,
            IsKnownThreat = true, // If it's in MalwareBazaar, it's a known threat
            ThreatName = GetThreatName(data),
            RiskLevel = riskLevel,
            ConfidenceScore = confidenceScore,
            Description = $"MalwareBazaar: {data.Signature} (VT: {data.VTPercent}%)",
            QueryTime = DateTime.UtcNow,
            FirstSeen = data.FirstSeen,
            LastSeen = data.LastSeen,
            Signature = data.Signature,
            ClamAV = data.ClamAV,
            VTPercent = data.VTPercent
        };
    }

    private List<MalwareBazaarResult> MapToResults(MalwareBazaarResponse? mbResponse)
    {
        var results = new List<MalwareBazaarResult>();
        
        if (mbResponse?.QueryStatus != "ok" || mbResponse.Data?.Any() != true)
            return results;

        foreach (var data in mbResponse.Data)
        {
            var result = new MalwareBazaarResult
            {
                Source = SOURCE_NAME,
                IsKnownThreat = true,
                ThreatName = GetThreatName(data),
                RiskLevel = CalculateRiskLevel(data),
                ConfidenceScore = CalculateConfidenceScore(data),
                Description = $"MalwareBazaar: {data.Signature} (VT: {data.VTPercent}%)",
                QueryTime = DateTime.UtcNow,
                FirstSeen = data.FirstSeen,
                LastSeen = data.LastSeen,
                Signature = data.Signature,
                ClamAV = data.ClamAV,
                VTPercent = data.VTPercent
            };
            results.Add(result);
        }

        return results;
    }

    private ThreatRiskLevel CalculateRiskLevel(MalwareBazaarData data)
    {
        // Use VirusTotal percentage as primary indicator
        return data.VTPercent switch
        {
            >= 80 => ThreatRiskLevel.Critical,
            >= 60 => ThreatRiskLevel.High,
            >= 30 => ThreatRiskLevel.Medium,
            > 0 => ThreatRiskLevel.Low,
            _ => ThreatRiskLevel.Low
        };
    }

    private float CalculateConfidenceScore(MalwareBazaarData data)
    {
        // Base confidence on VirusTotal percentage and signature presence
        var baseScore = data.VTPercent / 100.0f;
        
        // Boost confidence if we have a signature
        if (!string.IsNullOrEmpty(data.Signature))
            baseScore = Math.Min(1.0f, baseScore + 0.2f);
            
        // Boost confidence if we have ClamAV signature
        if (!string.IsNullOrEmpty(data.ClamAV))
            baseScore = Math.Min(1.0f, baseScore + 0.1f);

        return baseScore;
    }

    private string GetThreatName(MalwareBazaarData data)
    {
        if (!string.IsNullOrEmpty(data.Signature))
            return data.Signature;
            
        if (!string.IsNullOrEmpty(data.ClamAV))
            return data.ClamAV;
            
        return "Malware";
    }

    public void Dispose()
    {
        _rateLimitSemaphore?.Dispose();
    }
}
