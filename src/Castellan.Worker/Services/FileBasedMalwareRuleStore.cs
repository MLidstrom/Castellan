using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Castellan.Worker.Abstractions;
using Castellan.Worker.Models;
using Microsoft.Extensions.Logging;

namespace Castellan.Worker.Services;

/// <summary>
/// File-based implementation of YARA rule storage
/// </summary>
public class FileBasedMalwareRuleStore : IMalwareRuleStore
{
    private readonly ILogger<FileBasedMalwareRuleStore> _logger;
    private readonly string _rulesDirectory;
    private readonly string _rulesFilePath;
    private readonly string _matchesFilePath;
    private readonly object _lock = new object();
    
    public FileBasedMalwareRuleStore(ILogger<FileBasedMalwareRuleStore> logger)
    {
        _logger = logger;
        _rulesDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "data", "yara");
        _rulesFilePath = Path.Combine(_rulesDirectory, "rules.json");
        _matchesFilePath = Path.Combine(_rulesDirectory, "matches.json");
        
        // Ensure directory exists
        Directory.CreateDirectory(_rulesDirectory);
        
        // Initialize files if they don't exist
        if (!File.Exists(_rulesFilePath))
        {
            SaveRules(new List<MalwareRule>());
        }
        
        if (!File.Exists(_matchesFilePath))
        {
            SaveMatches(new List<MalwareMatch>());
        }
    }
    
    public Task<IEnumerable<MalwareRule>> GetAllRulesAsync()
    {
        lock (_lock)
        {
            var rules = LoadRules();
            return Task.FromResult<IEnumerable<MalwareRule>>(rules);
        }
    }

    public Task<(IEnumerable<MalwareRule> Rules, int TotalCount)> GetRulesPagedAsync(int page = 1, int limit = 25, string? category = null, string? tag = null, string? mitreTechnique = null, bool? enabled = null)
    {
        lock (_lock)
        {
            var allRules = LoadRules().AsQueryable();

            // Apply filters
            if (!string.IsNullOrEmpty(category))
                allRules = allRules.Where(r => r.Category == category);

            if (!string.IsNullOrEmpty(tag))
                allRules = allRules.Where(r => r.Tags.Contains(tag));

            if (!string.IsNullOrEmpty(mitreTechnique))
                allRules = allRules.Where(r => r.MitreTechniques.Contains(mitreTechnique));

            if (enabled.HasValue)
                allRules = allRules.Where(r => r.IsEnabled == enabled.Value);

            // Get total count
            var totalCount = allRules.Count();

            // Apply pagination
            var rules = allRules
                .OrderBy(r => r.Name)
                .Skip((page - 1) * limit)
                .Take(limit)
                .ToList();

            return Task.FromResult<(IEnumerable<MalwareRule>, int)>((rules, totalCount));
        }
    }
    
    public Task<IEnumerable<MalwareRule>> GetEnabledRulesAsync()
    {
        lock (_lock)
        {
            var rules = LoadRules().Where(r => r.IsEnabled);
            return Task.FromResult<IEnumerable<MalwareRule>>(rules);
        }
    }
    
    public Task<MalwareRule?> GetRuleByIdAsync(string id)
    {
        lock (_lock)
        {
            var rule = LoadRules().FirstOrDefault(r => r.Id == id);
            return Task.FromResult(rule);
        }
    }
    
    public Task<IEnumerable<MalwareRule>> GetRulesByCategoryAsync(string category)
    {
        lock (_lock)
        {
            var rules = LoadRules().Where(r => r.Category == category);
            return Task.FromResult<IEnumerable<MalwareRule>>(rules);
        }
    }
    
    public Task<MalwareRule> AddRuleAsync(MalwareRule rule)
    {
        lock (_lock)
        {
            var rules = LoadRules().ToList();
            
            // Ensure unique ID
            if (string.IsNullOrEmpty(rule.Id))
            {
                rule.Id = Guid.NewGuid().ToString();
            }
            
            // Set timestamps
            rule.CreatedAt = DateTime.UtcNow;
            rule.UpdatedAt = DateTime.UtcNow;
            
            rules.Add(rule);
            SaveRules(rules);
            
            _logger.LogInformation("Added YARA rule: {RuleName} ({RuleId})", rule.Name, rule.Id);
            return Task.FromResult(rule);
        }
    }
    
    public Task<MalwareRule> UpdateRuleAsync(MalwareRule rule)
    {
        lock (_lock)
        {
            var rules = LoadRules().ToList();
            var existingIndex = rules.FindIndex(r => r.Id == rule.Id);
            
            if (existingIndex == -1)
            {
                throw new InvalidOperationException($"Rule with ID {rule.Id} not found");
            }
            
            // Update timestamp
            rule.UpdatedAt = DateTime.UtcNow;
            
            // Increment version
            var existing = rules[existingIndex];
            rule.Version = existing.Version + 1;
            rule.PreviousVersion = JsonSerializer.Serialize(existing);
            
            rules[existingIndex] = rule;
            SaveRules(rules);
            
            _logger.LogInformation("Updated YARA rule: {RuleName} ({RuleId})", rule.Name, rule.Id);
            return Task.FromResult(rule);
        }
    }
    
    public Task<bool> DeleteRuleAsync(string id)
    {
        lock (_lock)
        {
            var rules = LoadRules().ToList();
            var removed = rules.RemoveAll(r => r.Id == id);
            
            if (removed > 0)
            {
                SaveRules(rules);
                _logger.LogInformation("Deleted YARA rule: {RuleId}", id);
                return Task.FromResult(true);
            }
            
            return Task.FromResult(false);
        }
    }
    
    public Task<bool> RuleExistsAsync(string name)
    {
        lock (_lock)
        {
            var exists = LoadRules().Any(r => r.Name == name);
            return Task.FromResult(exists);
        }
    }
    
    public Task UpdateRuleMetricsAsync(string ruleId, bool matched, double executionTimeMs)
    {
        lock (_lock)
        {
            var rules = LoadRules().ToList();
            var rule = rules.FirstOrDefault(r => r.Id == ruleId);
            
            if (rule != null)
            {
                if (matched)
                {
                    rule.HitCount++;
                }
                
                // Update average execution time
                var totalExecutions = rule.HitCount + (matched ? 0 : 1);
                rule.AverageExecutionTimeMs = 
                    ((rule.AverageExecutionTimeMs * (totalExecutions - 1)) + executionTimeMs) / totalExecutions;
                
                SaveRules(rules);
            }
            
            return Task.CompletedTask;
        }
    }
    
    public Task RecordFalsePositiveAsync(string ruleId)
    {
        lock (_lock)
        {
            var rules = LoadRules().ToList();
            var rule = rules.FirstOrDefault(r => r.Id == ruleId);
            
            if (rule != null)
            {
                rule.FalsePositiveCount++;
                SaveRules(rules);
                _logger.LogWarning("False positive recorded for rule: {RuleName} ({RuleId})", 
                    rule.Name, rule.Id);
            }
            
            return Task.CompletedTask;
        }
    }
    
    public Task<IEnumerable<MalwareRule>> GetRulesByMitreTechniqueAsync(string techniqueId)
    {
        lock (_lock)
        {
            var rules = LoadRules()
                .Where(r => r.MitreTechniques != null && r.MitreTechniques.Contains(techniqueId));
            return Task.FromResult<IEnumerable<MalwareRule>>(rules);
        }
    }
    
    public Task<IEnumerable<MalwareRule>> GetRulesByTagAsync(string tag)
    {
        lock (_lock)
        {
            var rules = LoadRules()
                .Where(r => r.Tags != null && r.Tags.Contains(tag));
            return Task.FromResult<IEnumerable<MalwareRule>>(rules);
        }
    }
    
    public Task<MalwareMatch> SaveMatchAsync(MalwareMatch match)
    {
        lock (_lock)
        {
            var matches = LoadMatches().ToList();
            
            // Ensure unique ID
            if (string.IsNullOrEmpty(match.Id))
            {
                match.Id = Guid.NewGuid().ToString();
            }
            
            if (match.MatchTime == default)
                match.MatchTime = DateTime.UtcNow;
            matches.Add(match);
            
            // Keep only recent matches (last 1000)
            if (matches.Count > 1000)
            {
                matches = matches.OrderByDescending(m => m.MatchTime).Take(1000).ToList();
            }
            
            SaveMatches(matches);
            
            _logger.LogInformation("YARA rule matched: {RuleName} on {TargetFile}", 
                match.RuleName, match.TargetFile);
            
            return Task.FromResult(match);
        }
    }
    
    public Task<IEnumerable<MalwareMatch>> GetRecentMatchesAsync(int count = 100)
    {
        lock (_lock)
        {
            var matches = LoadMatches()
                .OrderByDescending(m => m.MatchTime)
                .Take(count);
            return Task.FromResult<IEnumerable<MalwareMatch>>(matches);
        }
    }
    
    public Task<IEnumerable<MalwareMatch>> GetMatchesBySecurityEventAsync(string securityEventId)
    {
        lock (_lock)
        {
            var matches = LoadMatches()
                .Where(m => m.SecurityEventId == securityEventId);
            return Task.FromResult<IEnumerable<MalwareMatch>>(matches);
        }
    }
    
    private List<MalwareRule> LoadRules()
    {
        try
        {
            if (File.Exists(_rulesFilePath))
            {
                var json = File.ReadAllText(_rulesFilePath);
                return JsonSerializer.Deserialize<List<MalwareRule>>(json) ?? new List<MalwareRule>();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading YARA rules from file");
        }
        
        return new List<MalwareRule>();
    }
    
    private void SaveRules(List<MalwareRule> rules)
    {
        try
        {
            var json = JsonSerializer.Serialize(rules, new JsonSerializerOptions
            {
                WriteIndented = true
            });
            File.WriteAllText(_rulesFilePath, json);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error saving YARA rules to file");
            throw;
        }
    }
    
    private List<MalwareMatch> LoadMatches()
    {
        try
        {
            if (File.Exists(_matchesFilePath))
            {
                var json = File.ReadAllText(_matchesFilePath);
                return JsonSerializer.Deserialize<List<MalwareMatch>>(json) ?? new List<MalwareMatch>();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error loading YARA matches from file");
        }
        
        return new List<MalwareMatch>();
    }
    
    private void SaveMatches(List<MalwareMatch> matches)
    {
        try
        {
            var json = JsonSerializer.Serialize(matches, new JsonSerializerOptions
            {
                WriteIndented = true
            });
            File.WriteAllText(_matchesFilePath, json);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error saving YARA matches to file");
            throw;
        }
    }
}
